package jsonapi

import (
	"encoding/json"
	"errors"
	"reflect"
)

// Marshal ...
func Marshal(data interface{}) ([]byte, error) {
	document, err := marshalToStruct(data)
	if err != nil {
		return []byte(""), err
	}
	return json.Marshal(&document)
}

// MarshalErrors ...
func MarshalErrors(errors []Error) ([]byte, error) {
	doc, err := json.Marshal(Document{Errors: errors})
	if err != nil {
		return []byte(""), err
	}
	return doc, nil
}

func marshalToStruct(data interface{}) (Document, error) {
	if data == nil {
		return Document{}, nil
	}

	switch reflect.TypeOf(data).Kind() {
	case reflect.Slice:
		return marshalSlice(data)
	case reflect.Struct, reflect.Ptr:
		return marshalStruct(data.(ResourceGetIdentifier))
	default:
		return Document{}, errors.New("Marshal only accepts slice, struct or ptr types")
	}
}

func marshalSlice(data interface{}) (Document, error) {
	result := Document{}

	val := reflect.ValueOf(data)
	dataElements := []Data{}

	for i := 0; i < val.Len(); i++ {
		k := val.Index(i).Interface()
		element, ok := k.(ResourceGetIdentifier)
		if !ok {
			return result, errors.New("all elements within the slice must implement jsonapi.ResourceIdentifier")
		}

		content, err := marshalData(element)
		if err != nil {
			return result, err
		}

		dataElements = append(dataElements, *content)
	}

	// Data is always set
	result.Data = &DataContainer{
		DataArray: dataElements,
	}

	return result, nil
}

func marshalData(element ResourceGetIdentifier) (*Data, error) {
	var err error
	result := &Data{}

	refValue := reflect.ValueOf(element)
	if refValue.Kind() == reflect.Ptr && refValue.IsNil() {
		return result, errors.New("ResourceIdentifier must not be nil")
	}

	attributes, err := json.Marshal(element)
	result.Attributes = attributes
	result.ID = element.GetID()
	result.Type, err = getStructType(element)

	if err != nil {
		return nil, err
	}

	return result, nil
}

func marshalStruct(data ResourceGetIdentifier) (Document, error) {
	result := Document{}
	contentData, err := marshalData(data)
	if err != nil {
		return result, err
	}

	result.Data = &DataContainer{
		DataObject: contentData,
	}

	return result, nil
}

// getStructType is a helper function that takes a data interface that if it
// satisfies the ResourceTyper interface it returns the value generated by the
// GetName() func. If i interface is not of ResourceTyper type then an error
// is returned.
func getStructType(i interface{}) (string, error) {
	// check if the data satisfies the ResourceTyper interface
	en, ok := i.(ResourceTyper)
	if ok {
		return en.GetName(), nil
	}

	// TODO: Improve error message
	return "", errors.New("Struct must implement GetName().")
}
